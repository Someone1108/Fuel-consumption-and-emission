local({fn<-choose.files(filters=Filters[c('R','txt','All'),],index=4)
file.show(fn,header=fn,title='')})
5+7
exp(4)
ls()
ls()
ls()
ls()
rm(list=ls(all=TRUE))
x = 5+12
x
q()
y <- 12
x = y+ 45
library(readr)
WineQT <- read_csv("Datasets/WineQT.csv")
View(WineQT)
library(readr)
scoobydoo <- read_csv("Datasets/scoobydoo.csv")
View(scoobydoo)
install.packages("readxl")
mean(scoobydoo$run_time)
mean(scoobydoo$imdb)
mean(scoobydoo$imdb, na.rm = TRUE)
mean(scoobydoo$imd, na.rm = TRUE)
mean(scoobydoo$imdb, na.rm = TRUE)
mean(scoobydoo$imdb, na.rm = TRUE)
library(readxl)
mean(scoobydoo$imdb, data=scoobydoo[!is.null(scoobydoo$imdb)])
# Load necessary library
library(dplyr)
# Install dplyr package if not already installed
install.packages("dplyr")
# Load the dplyr library
library(dplyr)
# Assuming scoobydoo is your data frame and imdb_rating is the column with IMDb ratings
# Calculate the average IMDb rating
average_imdb_rating <- scoobydoo %>%
summarise(avg_rating = mean(imdb_rating, na.rm = TRUE))
# Install dplyr package if not already installed
install.packages("dplyr")
# Load the dplyr library
library(dplyr)
# Assuming scoobydoo is your data frame and imdb_rating is the column with IMDb ratings
# Calculate the average IMDb rating
average_imdb_rating <- scoobydoo %>%
summarise(avg_rating = mean(imdb, na.rm = TRUE))
# Print the result
print(average_imdb_rating)
# Install dplyr package if not already installed
install.packages("dplyr")
# Load the dplyr library
library(dplyr)
# Assuming scoobydoo is your data frame and imdb_rating is the column with IMDb ratings
# Calculate the average IMDb rating
average_imdb_rating <- scoobydoo %>%
summarise(avg_rating = mean(imdb, na.rm = TRUE))
# Print the result
print(average_imdb_rating)
# Assuming scoobydoo is your data frame and imdb_rating is the column with IMDb ratings
# Calculate the average IMDb rating
average_imdb_rating <- scoobydoo %>%
summarise(avg_rating = mean(imdb, na.rm = TRUE))
# Print the result
print(average_imdb_rating)
average_imdb_rating <- mean(scoobydoo$imdb, na.rm = TRUE)
# Print the result
print(average_imdb_rating)
scoobydoo$imdb <- as.numeric(as.character(scoobydoo$imdb))
# Calculate the average IMDb rating
average_imdb_rating <- scoobydoo %>%
summarise(avg_rating = mean(imdb, na.rm = TRUE))
# Print the result
print(average_imdb_rating)
mean(scoobydoo$imdb, na.rm = TRUE)
library(tidyverse)
install.packages("tidyverse")
library("leaflet")
library(leaflet)
install.packages("leaflet")
library(igraph)
install.packages("igraph")
library(igraph)
library(igraph)
dg <- graph.formula(1-+2, 1-+3, 2-+3, 2-+4) # so '1' owes '2'and '3' etc.
plot(dg)
V(dg)$name <- c("Adam", "Bob", "Con", "Doug") # names!
plot(dg, vertex.label = V(dg)$name)
is_weighted(dg)
wdg <- dg # copy, wdg is going to be a weighted directed graph
E(wdg)$weights <- runif(ecount(wdg)) * 1000 # random debts, up to $1000
plot(wdg, vertex.label = V(wdg)$name, edge.width=E(wdg)$weights)
E(wdg)$weights # as specified, random values from 0 to 1000
# so scale, but we might lose our arrows...
plot(wdg, vertex.label = V(wdg)$name, edge.width=E(wdg)$weights / 100
plot(wdg, vertex.label = V(wdg)$name, edge.width=E(wdg)$weights / 100, layout = layout.star)
G <- graph( c(1,2,1,3,1,4,3,4,3,5,5,6,6,7,7,8,8,9,3,8,5,8), directed = F )
# Plot the graph
plot(G, layout = layout.auto,
main = G$name,
vertex.label = V(G)$name,
vertex.size = 25,
vertex.color= V(G)$color,
vertex.frame.color= "white",
vertex.label.color = "white",
vertex.label.family = "sans",
edge.width=E(G)$weight,
edge.color="black")
library(igraph)
G <- graph( c(1,2,1,3,1,4,3,4,3,5,5,6,6,7,7,8,8,9,3,8,5,8), directed = F )
# Assign attributes to the graph
G$name <- "Change my layout, I dare you"
# Assign attributes to the graph's vertices
V(G)$name  <- toupper(letters[1:9])
V(G)$color <- sample(rainbow(9),9,replace=FALSE)
# Assign attributes to the edges
E(G)$weight <- runif(length(E(G)),.5,4)
# Plot the graph
plot(G, layout = layout.auto,
main = G$name,
vertex.label = V(G)$name,
vertex.size = 25,
vertex.color= V(G)$color,
vertex.frame.color= "white",
vertex.label.color = "white",
vertex.label.family = "sans",
edge.width=E(G)$weight,
edge.color="black
dg <- graph.formula(1-+2, 1-+3, 2-+3, 2-+4) # so '1' owes '2'and '3' etc.
plot(dg)
V(dg)$name <- c("Adam", "Bob", "Con", "Doug") # names!
plot(dg, vertex.label = V(dg)$name)
wdg <- dg # copy, wdg is going to be a weighted directed graph
E(wdg)$weights <- runif(ecount(wdg)) * 1000 # random debts, up to $1000
plot(wdg, vertex.label = V(wdg)$name, edge.width=E(wdg)$weights)
E(wdg)$weights # as specified, random values from 0 to 1000
# so scale, but we might lose our arrows...
plot(wdg, vertex.label = V(wdg)$name, edge.width=E(wdg)$weights / 100)
plot(wdg, vertex.label = V(wdg)$name, edge.width=E(wdg)$weights / 100, layout = layout.star)
install.packages("igraphdata")
library(igraphdata)
as_adjacency_matrix(karate
data(karate) # load the built-in graph data
?karate
V(karate)
E(karate)
as_adjacency_matrix(karate
as_adjacency_matrix(karate)
as_adjacency_matrix(karate)
library(igraphdata)
data(karate) # load the built-in graph data
?karate
V(karate)
E(karate)
as_adjacency_matrix(karate)
# Reproducible layout
set.seed(42)
# Now decorate, starting with labels and shapes
V(karate)$label <- sub("Actor ", "", V(karate)$name)
V(karate)$shape <- "circle"
# Differentiate two factions by color.
V(karate)[Faction == 1]$color <- "red"
V(karate)[Faction == 2]$color <- "dodgerblue"
# Vertex area proportional to vertex strength
# (i.e., total weight of incident edges).
V(karate)$size <- 4*sqrt(strength(karate))
V(karate)$size2 <- V(karate)$size * .5
# Weight edges by number of common activities
E(karate)$width <- E(karate)$weight
# Color edges by within/between faction.
F1 <- V(karate)[Faction==1]
F2 <- V(karate)[Faction==2]
E(karate)[ F1 %--% F1 ]$color <- "pink" # F1 to F1 i.e. internal
E(karate)[ F2 %--% F2 ]$color <- "lightblue"
E(karate)[ F1 %--% F2 ]$color <- "yellow"
# Offset vertex labels for smaller points (default = 0).
# or make all the circles bigger...
V(karate)$label.dist <- ifelse(V(karate)$size >= 10, 0, 0.75)
l <- layout.kamada.kawai(karate)
plot(karate, layout=l)
library(sand) # Statistical Analysis of Network Data with R
library(sna) # Tools for Social Network Analysis
library(network)
A = as_adjacency_matrix(karate, sparse=FALSE)
g = network::as.network.matrix(A) # make a matrix
par(mfrow=c(1,1))
sna::gplot.target(
g, degree(g), main="Degree",
circ.lab = FALSE, # change to TRUE to see legend on concentric blue circles
circ.col="skyblue", usearrows = FALSE,
vertex.col=c("blue", rep("red", 32), "yellow"),
edge.col="darkgray"
)
library(sna) # Tools for Social Network Analysis
install.packages("sna")
library(sand) # Statistical Analysis of Network Data with R
install.packages("sand")
library(sand) # Statistical Analysis of Network Data with R
library(sna) # Tools for Social Network Analysis
library(network)
A = as_adjacency_matrix(karate, sparse=FALSE)
g = network::as.network.matrix(A) # make a matrix
par(mfrow=c(1,1))
sna::gplot.target(
g, degree(g), main="Degree",
circ.lab = FALSE, # change to TRUE to see legend on concentric blue circles
circ.col="skyblue", usearrows = FALSE,
vertex.col=c("blue", rep("red", 32), "yellow"),
edge.col="darkgray"
)
par(mfrow=c(2,2))
par(mar=c(1.5, 1, 1, 0.5))
sna::gplot.target(
g, degree(g), main="Degree",
circ.lab = FALSE, # change to TRUE to see legend on concentric blue circles
circ.col="skyblue", usearrows = FALSE,
vertex.col=c("blue", rep("red", 32), "yellow"),
edge.col="darkgray"
)
sna::gplot.target(g, closeness(g), main="Closeness",
circ.lab = FALSE, circ.col="skyblue",
usearrows = FALSE,
vertex.col=c("blue", rep("red", 32), "yellow"),
edge.col="darkgray")
sna::gplot.target(g, betweenness(g), main="Betweenness",
circ.lab = FALSE, circ.col="skyblue",
usearrows = FALSE,
vertex.col=c("blue", rep("red", 32), "yellow"),
edge.col="darkgray")
sna::gplot.target(g, evcent(g), main="Eigenvalue",
circ.lab = FALSE, circ.col="skyblue",
usearrows = FALSE,
vertex.col=c("blue", rep("red", 32), "yellow"),
edge.col="darkgray")
displaylabels = TRUE
par(mfrow=c(2,2))
sna::gplot.target(
g, degree(g), main="Degree",
circ.lab = FALSE, # change to TRUE to see legend on concentric blue circles
circ.col="skyblue", usearrows = FALSE,
vertex.col=c("blue", rep("red", 32), "yellow"),
edge.col="darkgray", displaylabels=TRUE
)
sna::gplot.target(g, closeness(g), main="Closeness",
circ.lab = FALSE, circ.col="skyblue",
usearrows = FALSE,
vertex.col=c("blue", rep("red", 32), "yellow"),
edge.col="darkgray", displaylabels=TRUE)
sna::gplot.target(g, betweenness(g), main="Betweenness",
circ.lab = FALSE, circ.col="skyblue",
usearrows = FALSE,
vertex.col=c("blue", rep("red", 32), "yellow"),
edge.col="darkgray", displaylabels=TRUE)
sna::gplot.target(g, evcent(g), main="Eigenvalue",
circ.lab = FALSE, circ.col="skyblue",
usearrows = FALSE,
vertex.col=c("blue", rep("red", 32), "yellow"),
edge.col="darkgray", displaylabels=TRUE)
par(mfrow=c(2,1)) # make two plots up and down
par(mar=c(0.5, 1, 1, 1))
kk.layout <- layout.kamada.kawai(G) # make a consistent layout for the graphs
# make the left plot
com <- cluster_edge_betweenness(G)
V(G)$color <- com$membership+1
plot(G, vertex.label.dist=.75,layout=kk.layout,
main="Cluster Edge-Betweenness",
edge.arrow.size=0.25)
# make the right plot
com <- cluster_walktrap(G)
V(G)$color <- com$membership+1
plot(G, vertex.label.dist = .75, layout=kk.layout,
main="Cluster Walktrap",
edge.arrow.size=0.25)
# Load necessary libraries
library(ggplot2)
library(maps)
library(ggspatial)
# Base map of Australia
australia_map <- map_data("world", region = "Australia")
# Define coordinates for cities
long_sydney <- 151.2093
lat_sydney <- -33.8688
long_melbourne <- 144.9631
lat_melbourne <- -37.8136
long_brisbane <- 153.0281
lat_brisbane <- -27.4698
long_perth <- 115.8575
lat_perth <- -31.9505
# Define costs for car and plane (for example purposes)
cost_for_car <- 1 # This value represents the thickness of the car route
cost_for_plane <- 1 # This value represents the thickness of the plane route
# Create the plot
ggplot() +
geom_polygon(data = australia_map, aes(x = long, y = lat, group = group), fill = "lightblue", color = "black") +
# Car route (Sydney to Melbourne)
geom_curve(aes(x = long_sydney, y = lat_sydney, xend = long_melbourne, yend = lat_melbourne),
curvature = 0.2, color = "blue", size = cost_for_car, linetype = "solid") +  # Adjust size for cost
# Plane route (Sydney to Melbourne)
geom_curve(aes(x = long_sydney, y = lat_sydney, xend = long_melbourne, yend = lat_melbourne),
curvature = -0.2, color = "red", size = cost_for_plane, linetype = "dashed") +  # Adjust size for cost
# Car route (Melbourne to Brisbane)
geom_curve(aes(x = long_melbourne, y = lat_melbourne, xend = long_brisbane, yend = lat_brisbane),
curvature = 0.3, color = "blue", size = cost_for_car, linetype = "solid") +
# Plane route (Melbourne to Brisbane)
geom_curve(aes(x = long_melbourne, y = lat_melbourne, xend = long_brisbane, yend = lat_brisbane),
curvature = -0.3, color = "red", size = cost_for_plane, linetype = "dashed") +
# Car route (Melbourne to Perth)
geom_curve(aes(x = long_melbourne, y = lat_melbourne, xend = long_perth, yend = lat_perth),
curvature = 0.4, color = "blue", size = cost_for_car, linetype = "solid") +
# Plane route (Melbourne to Perth)
geom_curve(aes(x = long_melbourne, y = lat_melbourne, xend = long_perth, yend = lat_perth),
curvature = -0.4, color = "red", size = cost_for_plane, linetype = "dashed") +
# Add labels or annotations
annotate("text", x = long_sydney, y = lat_sydney, label = "Car: 100 AUD, 50 kg CO2", vjust = 1.5) +
annotate("text", x = long_melbourne, y = lat_melbourne, label = "Plane: 150 AUD, 30 kg CO2", vjust = 1.5) +
annotate("text", x = long_brisbane, y = lat_brisbane, label = "Brisbane", vjust = 1.5) +
annotate("text", x = long_perth, y = lat_perth, label = "Perth", vjust = 1.5) +
# Legend and titles
labs(title = "Cost and Emission Comparison for Travel Routes",
subtitle = "Comparing Car vs Plane travel between major Australian cities") +
theme_minimal()
shiny::runApp('C:/Users/AmanRoy/Desktop/Monash_desktop/Data analysis/DATA VISUALIZATION PROJECT/PART 2/Visual/testing')
Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
1+1
1+1
1+1
this is text
this is text
this is text
this is my test
```{r}
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
1+1
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
1+1
library(tidyverse)
# Load tidyverse
library(tidyverse)
# Read melb_walk.csv from GitHub URL and store in object named ped_wide
ped_wide <- read_csv("https://raw.githubusercontent.com/quangvanbui/FIT5145-data/master/melb_walk_wide.csv")
# Alternatively, read it from your working directory
ped_wide <- read_csv("melb_walk_wide.csv")
# Print ped_wide
ped_wide
# First and last date in the data
ped_wide %>%
arrange(Date) %>%
summarise(first_date = first(Date),
last_date = last(Date))
view(ped_wide)
ped <- ped_wide %>%
gather(key = ???, value = Count, -Date_Time, -Date, -Time) %>%
ped <- ped_wide %>%
gather(key = Sensor, value = Count, -Date_Time, -Date, -Time) %>%
# Not necessary but there we use select() to rearrange the columns
select(Sensor, everything(), Count)
# Convert the data into a long form
ped <- ped_wide %>%
gather(key = Sensor, value = Count, -Date_Time, -Date, -Time) %>%
# Not necessary but there we use select() to rearrange the columns
select(Sensor, everything(), Count)
# Print ped
ped
# Print state_lib_jan_one
state_lib_jan_one
state_lib_jan_one <- ped %>%
filter(Date == "2019-01-01", Sensor == "State Library")
# Print state_lib_jan_one
state_lib_jan_one
```{r eval=FALSE}
state_lib_jan_one <- ped %>%
filter(Date == "2019-01-01", Sensor == "State Library")
# Print state_lib_jan_one
state_lib_jan_one
# Line plot of State Library pedestrian count
state_lib_jan_one %>%
ggplot(aes(x = Date , y = Date_Time )) +
geom_line()
# Line plot of State Library pedestrian count
state_lib_jan_one %>%
ggplot(aes(x = Date_Time , y = Date_Time )) +
geom_line()
# Line plot of State Library pedestrian count
state_lib_jan_one %>%
ggplot(aes(x = Date_Time , y = Count )) +
geom_line()
```{r}
# Bar plot of count
state_lib_jan_one %>%
ggplot(aes(x = Time, y = Count)) +
geom_bar(stat = "identity")
# Filter for State Library data on Jan 1, 2019
state_lib_jan_one <- ped %>%
filter(Date == "2019-01-01", Sensor == "State Library")
# Print state_lib_jan_one
state_lib_jan_one
# Filter for State Library data on Jan 1, 2019
state_lib_jan_one <- ped %>%
filter(Date == "2019-01-01", Sensor == "State Library")
# Print state_lib_jan_one
state_lib_jan_one
# Filter for State Library data on Jan 1, 2019
state_lib_jan_one <- ped %>%
filter(Date == "2019-01-01", Sensor == "State Library")
# Print state_lib_jan_one
state_lib_jan_one
# Line plot of State Library pedestrian count
state_lib_jan_one %>%
ggplot(aes(x = Date_Time , y = Count )) +
geom_line()
# Line plot of State Library pedestrian count
state_lib_jan_one
shiny::runApp('C:/Users/AmanRoy/Desktop/Monash_desktop/semester 1/Data analysis/DATA VISUALIZATION PROJECT/PART 2/Visual')
